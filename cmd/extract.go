package cmd

import (
	"fmt"
	"strings"

	"github.com/simonw/showboat/markdown"
)

// Extract parses a showboat document and returns the sequence of CLI commands
// that would recreate it. OutputBlock and ImageOutputBlock are skipped since
// they are generated by running code blocks. If outputFile is non-empty it is
// used as the filename in the emitted commands; otherwise the input file path
// is used.
func Extract(file, outputFile string) ([]string, error) {
	blocks, err := readBlocks(file)
	if err != nil {
		return nil, err
	}

	target := file
	if outputFile != "" {
		target = outputFile
	}
	quotedTarget := shellQuote(target)

	var commands []string

	for _, block := range blocks {
		switch b := block.(type) {
		case markdown.TitleBlock:
			commands = append(commands, fmt.Sprintf("showboat init %s %s", quotedTarget, shellQuote(b.Title)))
		case markdown.CommentaryBlock:
			commands = append(commands, fmt.Sprintf("showboat note %s %s", quotedTarget, shellQuote(b.Text)))
		case markdown.CodeBlock:
			if b.IsImage {
				commands = append(commands, fmt.Sprintf("showboat image %s %s", quotedTarget, shellQuote(b.Code)))
			} else if b.IsServer {
				commands = append(commands, fmt.Sprintf("showboat server %s %s %s", quotedTarget, b.Lang, shellQuote(b.Code)))
			} else {
				commands = append(commands, fmt.Sprintf("showboat exec %s %s %s", quotedTarget, b.Lang, shellQuote(b.Code)))
			}
		case markdown.OutputBlock:
			// Skip: generated by running code blocks
		case markdown.ImageOutputBlock:
			// Skip: generated by running image scripts
		}
	}

	return commands, nil
}

// shellQuote wraps a string in single quotes if it contains spaces, special
// characters, or is empty. Otherwise it returns the string as-is.
func shellQuote(s string) string {
	if s == "" {
		return "''"
	}
	// Characters that need quoting in a shell context
	needsQuoting := false
	for _, c := range s {
		if c == ' ' || c == '\t' || c == '\n' || c == '"' || c == '\'' ||
			c == '\\' || c == '|' || c == '&' || c == ';' || c == '(' ||
			c == ')' || c == '<' || c == '>' || c == '$' || c == '`' ||
			c == '!' || c == '{' || c == '}' || c == '[' || c == ']' ||
			c == '*' || c == '?' || c == '#' || c == '~' {
			needsQuoting = true
			break
		}
	}
	if !needsQuoting {
		return s
	}
	// Use single quotes, escaping any embedded single quotes
	escaped := strings.ReplaceAll(s, "'", "'\\''")
	return "'" + escaped + "'"
}
